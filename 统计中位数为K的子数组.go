package main

func main() {

}

func countSubarrays(nums []int, k int) int {
	// 既然是中位数，因此 大于k的数 = 小于k的数，拆分一下：
	// 左边小于k的数 + 右边小于k的数 = 左边大于k的数 + 右边大于k的数  移项
	// 左边小于k的数 - 左边大于k的数 = 右边大于k的数 - 右边小于k的数
	// 此时可以分开看左边和右边的部分，只需要保证等号左边的值 与 等号右边的值相等就行
	// 我们将等式 左/右边大于/小于的数 的系数拿出来
	// 也就是 左边小于k的数 = 1；左边大于k的数 = -1；右边大于k的数 = 1；右边小于k的数 = -1
	// 同时设中位数本身为 0

	// 以上等式面向子数组是奇数长度的时候考虑的
	// 如果是偶数，则 大于k的数 = 小于k的数 + 1 （根据题目条件，偶数长度中位数取前面一个）
	// 因此： 左边小于k的数 - 左边大于k的数 = 右边大于k的数 - 右边小于k的数 + 1

	// 由于需要的是子数组，因此不能对原本的数组进行排序，且数组应该是连续的
	// 所以我们以中位数所在的idx为界，先遍历一侧，统计等式其中一侧，在每一步的值
	// 等到遍历另一侧的时候，只要存在相同的值，那么就是一个符合要求的子数组
	// 如果是偶数的情况，只需要把 右侧数量+1 的情况考虑进去就行
	count := 0
	cnt := make(map[int]int)
	idx := 0
	for i, num := range nums {
		if num == k {
			idx = i
			break
		}
	}
	cnt[0] = 1
	for i := idx + 1; i < len(nums); i++ {
		if nums[i] > k {
			count++
		} else {
			count--
		}
		cnt[count]++
	}
	count = 0
	// 这里的 1 和下面的 +1 是在上面先往右边遍历确定的，如果先往左边遍历，这里应该是 -1，下面也应该是 count-1
	ans := cnt[0] + cnt[1]
	for i := idx - 1; i >= 0; i-- {
		if nums[i] > k {
			count--
		} else {
			count++
		}
		ans += cnt[count] + cnt[count+1]
	}
	return ans
}
